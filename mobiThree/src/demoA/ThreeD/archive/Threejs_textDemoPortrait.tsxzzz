
no longer used

import React, { ReactDOM, useEffect, useState, useRef } from 'react';
import devProjCSS from './devProject.module.css'

import * as THREE from 'three';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';// import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
import { QuatAreFun } from './quaternionsAreFun';
import { getSunHorizCords } from '../galactic/altAz'
import { DisplaySpec } from '../Sensors';
// to get intellisense to work: npm install --save-dev @types/three
var theFont, theMaterialTexture
var sceneA:THREE.Scene
var theThreejsRenderer:THREE.WebGLRenderer
var theThreejsCam:THREE.Camera

const cameraZ = 444

/** because dispSpec is a useState thing in caller, and this component
 *  has it as a param, it gets redrawn upon any change.
 *  WARNING: THREE.quaterion is w, x, y z unlike web sensor api which is x, y, z, w  
 *  new THREE.Quaternion() gives w:1, x:0, y:0, z:0
 */
function DoThreejs_textDemoA(props3) {

    /**
     * 
     * @param theFont 
     * @param dispSpec 
     * @param deviceOrienQuatArray output of web API "AbsoluteOrientationSensor". number[4]
     * Converts web API quaternion to THREE.Quaternion, rotates it to landscape and draws scene  
     * where light source tracks this quaternion. Provides illusion of fixed light shining  
     * onto scene in moving mobile device.
     */
    function doDrawSensor(theFont, dispSpec:DisplaySpec, deviceOrienQuatArray:number[]) {
        while (sceneA.children.length > 0) sceneA.remove(sceneA.children[0]);
        var lightSourceQuat:THREE.Quaternion = new THREE.Quaternion(...deviceOrienQuatArray)
        var invertedOrientation = lightSourceQuat.clone().invert() 
        //drawBall(invertedOrientation)
        doDraw(theFont, dispSpec, QuatAreFun.quatPointingAlongXaxis(false))
        //doDraw(theFont, dispSpec, QuatAreFun.quaternionFromAltAz(-10, 10, false))
    }

    function zzdoDrawSensor(theFont, dispSpec:DisplaySpec, deviceOrienQuatArray:number[]) {
        var lightSourceQuat:THREE.Quaternion = new THREE.Quaternion(...deviceOrienQuatArray)
        // drawBall(lightSourceQuat)
        // To align sensor space with landscape, rotate around the Z-axis by -90 degrees (Math.PI / 2 radians)
        ////QuatAreFun.rotateOnZaxisBy90(lightSourceQuat)
        // dispSpec.text += 'tttt'
        // to get earth-fixed location, invert device orientation
        while (sceneA.children.length > 0) sceneA.remove(sceneA.children[0]);
        var invertedOrientation = lightSourceQuat.clone().invert() 
        doDraw(theFont, dispSpec, invertedOrientation)

        // // testing:
        // // whoops doDraw inverts quaterion ??
        var qq = new THREE.Quaternion(1, 0, 0); 
        // QuatAreFun.rotateOnZaxisBy90(qq)
        // //qq.normalize()
        doDraw(theFont, dispSpec, qq)
        // qq = new THREE.Quaternion(0.5, 1, 0);
        // doDraw(theFont, dispSpec, qq)
    }

    /** !!! useEffect() !!! is React's lifecycle event, like onLoad(), onRefresh() etc. 
     *  It runs depending on the second arg:
     *  missing -> run once when page loads
     *  [props3.flavor] -> runs only when props3.flavor changes value
     *  [] -> run every time
    */
    useEffect(() => { 
        if (sceneA) {
            const res = getSunHorizCords();
            doDrawSensor(theFont, props3.dispSpec, props3.deviceOrienQuatArray)
        }
    }, [props3.dispSpec]); 
    useEffect(() => { 
        if (!theCanvas.current) return; // DONT use querySelector() use useRef()...
        sizeCanvasToParent_shrinkInsideBorder_rotate90_setCamAspectRatio();
        // sizeCanvasToParent_shrinkInsideBorder_setCamAspectRatio()
        setupFontNScene(theCanvas.current).then(() => {
            doDrawSensor(theFont, props3.dispSpec, props3.deviceOrienQuatArray)
        })
        canvWidth.current = Number.parseInt(theCanvas.current!.style.width)
        canvHeight.current = Number.parseInt(theCanvas.current!.style.height)
        const res = getSunHorizCords();
    }, []); 
    var canvHeight = useRef<number>(0), canvWidth = useRef<number>(0); // use type or warning msg
    const orlCt = useRef(0)
    const bwidth = '11px'
    const theCanvas = useRef<HTMLCanvasElement>(null)
    /**
     * the canvas object is where THREE.JS does its thing. 
     * Setting the css "transform" of the canvas to 90 deg rotate resets the entire
     * THREE.JS world on its side. does this so phone length is width, y axis this way too.
     */
    
    return <canvas ref={theCanvas}
        style={{border:bwidth + ' solid red'}}>this is DoThreejs_textDemoA!</canvas>


function toRads(deg) { return  deg * (Math.PI / 180)}

function drawBall(lightSrcQuat) {
    const THREE_material = new THREE.MeshStandardMaterial({
            color: 0xffffff, roughness: .5, metalness: .8, map: theMaterialTexture 
        });
    const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(88), THREE_material);
    const ballX = 0 //canvWidth.current/2 // 0 // 222
    const ballY = 0 //canvHeight.current/2
    ballMesh.position.set(ballX, ballY, 0)
    sceneA.add(ballMesh)
    var liteA
    sceneA.add(liteA = orbitLight(
                new THREE.RectAreaLight(0x00ff00, 222, 99, 99 ), 
                111, 0, 0, 0, lightSrcQuat))
    sceneA.add(new RectAreaLightHelper(liteA))

    sceneA.add(new THREE.AmbientLight(0xffffff, 1));
    sceneA.add(new THREE.HemisphereLight(0xFCE570, 0x9B7653, 10));
    sceneA.background = new THREE.Color( 0x000022 )
    // fixes pixelly appearance
    theThreejsCam = new THREE.OrthographicCamera(
            -canvWidth.current, canvWidth.current, 
            canvHeight.current, -canvHeight.current, 0.1, 2000); // top, bottom, near, far
    theThreejsCam.position.set( 0, 0, cameraZ );

    theThreejsRenderer.setPixelRatio(window.devicePixelRatio);
    theThreejsRenderer.render(sceneA, theThreejsCam);
}
/** 
 * @param theFont - A loaded Three.js font used to create the 3D text geometry.
 * @param dispSpec 
 * @param lightSrcQuat - Light source direction, typically updated to inverse device orientation  
 *        to simulate stationary light shining on moving device.  
 *        Needs to be already z-axis rotated 90 to conform to landscape
 * */
function doDraw(theFont, dispSpec:DisplaySpec, 
                lightSrcQuat:THREE.Quaternion) {
        
        // const THREE_material = new THREE.MeshPhongMaterial ({ 
        //          color: 0xffffff, specular: 0x00ff00, shininess: .001, 
        //          reflectivity: .8, transparent: false })     
        //  const THREE_material = new THREE.MeshStandardMaterial()
        const THREE_material = new THREE.MeshStandardMaterial({
            color: 0xffffff, roughness: .5, metalness: .8, map: theMaterialTexture 
        });
        const textGeometry = new TextGeometry(' '+ dispSpec.text, // sensorPitch, 
            {   font: theFont, size: 180, 
                depth: 88, // how thick each 3d character is
                curveSegments: 22, bevelEnabled: true, bevelThickness: 9, bevelSize: 9    
            }
        )
        const textMesh = new THREE.Mesh(textGeometry, THREE_material);
        textMesh.position.set(-338, 0, 0)
        // tilt the mesh--no longer done tilt cam instead .... textMesh.rotation.set(0, -Math.PI/8, 0)
        sceneA.add(textMesh)
        //earthLites(theThreejsScene, dispSpec.elevation, 222, -333, 0, 300) 

        const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(88), THREE_material);
        const ballX = 0 //canvWidth.current/2 // 0 // 222
        const ballY = 0 //canvHeight.current/2
        ballMesh.position.set(ballX, ballY, 0)
        sceneA.add(ballMesh)
        //theThreejsScene.add(new THREE.DirectionalLightHelper(movingLightA))
        var liteA, liteB
        var color = 0x00ffff // (Math.floor(orlCt.current += 1 / 5) % 2 === 0) ? 0x00ffff : 0xff0000  // flashes!
        
        // SUNSHINE!
        sceneA.add(liteA = orbitLight(
                new THREE.RectAreaLight(0x00ff00, 222, 99, 99 ), 
                111, ballX, ballY, 0, lightSrcQuat))
        sceneA.add(new RectAreaLightHelper(liteA))
        // sceneA.add(liteB = orbitLight(
        //         new THREE.PointLight(color, 222, 0, 0), // distance decay 0 == none. Default 2 == very very dim.
        //         222, ballX, ballY, 33, lightSrcQuat))
        // sceneA.add(new THREE.PointLightHelper(liteB, 22))

        
        // CAMERA!, tilted to get 3d effect
        // copycopy
        theThreejsCam = new THREE.OrthographicCamera(
            -canvWidth.current, canvWidth.current, 
            canvHeight.current, -canvHeight.current, 0.1, 2000); // top, bottom, near, far
        // theThreejsCam.rotation.set(0, Math.PI/22, 0); 
        // theThreejsCam.position.set( canvWidth.current/2, -canvHeight.current/2, cameraZ );
        theThreejsCam.position.set( 0, 0, cameraZ );

        // LIGHTS!
        sceneA.add(new THREE.AmbientLight(0xffffff, 1));
        sceneA.add(new THREE.HemisphereLight(0xFCE570, 0x9B7653, 10));
        sceneA.background = new THREE.Color( 0x000022 )
        // fixes pixelly appearance
        theThreejsRenderer.setPixelRatio(window.devicePixelRatio);

        // ACTION!
        theThreejsRenderer.render(sceneA, theThreejsCam);
    }

    /** LightAtPlace
     * @param {THREE.Light} lightA
     * @param {number} distance - Of the light.
     * @param {THREE.Quaternion} lightSourceQuat - orientation of light source  
     *    which has been transformed to portrait or landscape space.
     **/
    function LightAtPlace(lightA:THREE.Light, distance, lightSourceQuat:THREE.Quaternion) {
        /* start with light on y axis overhead. Then use quaternion to rotate the vector.
           Quaternions can only do orientation, not absolute location! */
        const vecLightPosition = new THREE.Vector3(0, 0, distance); // initial position
        //quatTHREE.slerp(new THREE.Quaternion(1, 0, 0), 1)
        // rotate from 0, 0 based on sensor. Use clone cuz invert() modifies it and breaks for next element
        vecLightPosition.applyQuaternion(lightSourceQuat.clone().invert()); 
        lightA.lookAt(0,0,0) // "aim" light to origin
        return lightA
    }

    /** orbit light according to quaternion. jsdoc made by copilot!
     * @param {THREE.Light} lightA
     * @param {number} orbitAlt - The altitude of the orbit path.
     * @param {number} centerX - X-coordinate of the orbit center.
     * @param {number} centerY - Y-coordinate of the orbit center.
     * @param {number} centerZ - Z-coordinate of the orbit center.
     * @param {THREE.Quaternion} lightSourceQuat - data from Web Api AbsoluteOrientationSensor which has been transformed to portrait or landscape space.
     **/
    function orbitLight(lightA:THREE.Light, orbitAlt, centerX, centerY, centerZ, lightSourceQuat:THREE.Quaternion) {
        /* start with light on y axis overhead. Then use quaternion to rotate the vector.
           Quaternions can only do orientation, not absolute location! */
        const vecLightPosition = new THREE.Vector3(0, 0, orbitAlt); // initial position
        //quatTHREE.slerp(new THREE.Quaternion(1, 0, 0), 1)
        // rotate from 0, 0 based on sensor. Use clone cuz invert() modifies it and breaks for next element
        vecLightPosition.applyQuaternion(lightSourceQuat); 
        // bump the newly aimed vector to its actual position
        vecLightPosition.x += centerX; vecLightPosition.y += centerY; vecLightPosition.z += centerZ
        lightA.position.copy(vecLightPosition); // apply vecgtor to the light
        lightA.lookAt(centerX, centerY, centerZ) // "aim" the light direction
        return lightA
    }

    /** carries out 90 degree rotation to landscape format.
     *  swaps width/height etc. 3d transforms are now messed up & need compensation
     */
    function sizeCanvasToParent_shrinkInsideBorder_rotate90_setCamAspectRatio() {
        var bwidth:number = Number.parseInt(theCanvas.current!.style.borderWidth)
        theCanvas.current!.style.height = 
            // to get rid of TS warnings, use the non-null assertion operator (!)
            (theCanvas.current!.parentElement!.clientHeight - bwidth*2) + 'px'
        theCanvas.current!.style.width = 
            (theCanvas.current!.parentElement!.clientWidth - bwidth*2) + 'px'
        // do the move-rotate-move thing because axis of rotation is corner of screen

        //////////////////////////////////////////
        // var xform = 'translate(-50%, -50%) ' + // move corner to origin
        //         'rotateZ(90deg) ' // rotate around origin
        //         + 'translate(50%, -50%) ' // move back into place
        // theCanvas.current!.style.transform = xform;

        // now have fun with messed up 3d xforms!
    }

    function sizeCanvasToParent_shrinkInsideBorder_setCamAspectRatio() {
        var bwidth:number = Number.parseInt(theCanvas.current!.style.borderWidth)
        theCanvas.current!.style.width = 
            // to get rid of TS warnings, use the non-null assertion operator (!)
            (theCanvas.current!.parentElement!.clientWidth - bwidth*2) + 'px'
        theCanvas.current!.style.height = 
            (theCanvas.current!.parentElement!.clientHeight - bwidth*2) + 'px'
    }

    /**
     * Converted to return promise by Copilot
     * @param canvasA for setting up stuff
     * @returns Promise when font has been loaded (may take some time)
     * Contains 2 nested asynchronous functions, one to load font and another to load Texture
     */
    function setupFontNScene(
        canvasA: HTMLCanvasElement,
        ): Promise<void> {
        console.log('init');
        sceneA = new THREE.Scene();
        theThreejsRenderer = new THREE.WebGLRenderer({ canvas: canvasA, antialias: true });
        // does not return the new font. Returns a Promise (callback) to invoke when completed
        return new Promise((resolve, reject) => {
            // now create th anonymous (no name) promise function
            const fontLoader = new FontLoader();
            fontLoader.load(  // asynchronous. Returns immediately without doing work. Invokes callback when loaded.
                '/fonts/helvetiker_regular.typeface.json', // url param for load
                (font: any) => {  // define onLoad param function. We have the font. Now load the Texture.
                    theFont = font
                    // now do the asynchronous thing again for THREE.TextureLoader
                    new THREE.TextureLoader().load( // another asynchronous function
                        '/jpeg/circle.svg',
                        (texture: THREE.Texture) => {  // here's the callback for the load() fcn
                            theMaterialTexture = texture;
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            texture.repeat.set(22, 22);
                            resolve(); // asynchronous successful. OR reject()
                        }, // TextureLoader onLoad function
                        undefined, // onProgress
                        (err) => { console.error('Texture load error:', err); reject(err); } // reject()
                    ); // TextureLoader.load
                },  // FontLoader onLoad function
            undefined, // onProgress
            (err) => { console.error('Font load error:', err); reject(err); }
            ); // fontLoader.load
        });
    }
}

export { DoThreejs_textDemoA }

/*
// this works but has discontinuities. Using quaterion instead of euler -> sceneA.add(foo = orbitRectLight_euler(dispSpec.elevation, 0xffff00, 5, 333, ballX, ballY, 33))
        
     first try before using quaternion. This only goes by elevation. 
    function orbitRectLight_euler(elevation, color, intensity, orbitAlt, centerX, centerY, centerZ) {
        if (Math.floor(orlCt.current += 1 / 5) % 2 === 0) color=0x00ffff // flashes!
        const movingLightA = new THREE.RectAreaLight(color, 999,  99, 99 );
        // using euler move light on xy plane only.
        movingLightA.position.set(
            centerX - orbitAlt * Math.sin(toRads(elevation)), 
            centerY + orbitAlt * Math.cos(toRads(elevation)), centerZ)
        movingLightA.lookAt(centerX, centerY, 0)
        return movingLightA
        // const a = new THREE.Euler( 0, 0, .7, 'XYZ' );
        // quat.setFromEuler(a)
    }


$('#x').draggable();
$('#c').droppable({

const quatParamFromWebApiSensor:number[] = [ props3.quat[0], props3.quat[1], props3.quat[2], props3.quat[3] ]
            
*/
